<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>THE PARKING LAB - V16.3 (Final Tuned)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-dark: #050505;
            --panel-bg: rgba(20, 30, 40, 0.9);
            --neon-cyan: #00F3FF;
            --neon-orange: #FF9E00;
            --neon-red: #FF003C;
            --neon-white: #E0FFFF;
            --text-primary: #E0F7FA;
            --text-secondary: #5DA3B5;
            
            --sidebar-width: 320px;
            --border-radius: 12px;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-primary);
            font-family: 'Orbitron', sans-serif;
            margin: 0;
            height: 100vh;
            display: flex;
            overflow: hidden;
            user-select: none;
        }

        /* --- ÁßªÂä®Á´ØÂ±èËîΩ --- */
        #mobile-blocker {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px); z-index: 9999;
            flex-direction: column; align-items: center; justify-content: center;
            text-align: center; padding: 40px; box-sizing: border-box;
            border: 2px solid var(--neon-red);
        }
        @media (max-width: 1024px) { #mobile-blocker { display: flex; } #app-container { filter: blur(10px); pointer-events: none; } }
        .mobile-icon { font-size: 60px; margin-bottom: 20px; color: var(--neon-red); text-shadow: 0 0 20px var(--neon-red); }
        .mobile-title { font-size: 24px; font-weight: 700; margin-bottom: 10px; color: var(--neon-red); letter-spacing: 2px; }
        .mobile-desc { font-size: 14px; color: var(--text-primary); line-height: 1.6; }

        /* --- Â∏ÉÂ±Ä --- */
        #app-container { display: flex; width: 100%; height: 100%; }

        /* Â∑¶‰æßËæπÊ†è */
        #sidebar {
            width: var(--sidebar-width); min-width: var(--sidebar-width);
            background: linear-gradient(180deg, rgba(12,20,28,1) 0%, rgba(5,8,12,1) 100%);
            display: flex; flex-direction: column;
            padding: 30px; box-sizing: border-box;
            justify-content: space-between; z-index: 20;
            box-shadow: 10px 0 40px rgba(0, 243, 255, 0.05); 
            border-right: none; 
        }

        /* Brand Header */
        #brand-header {
            text-align: center; margin-bottom: 30px; padding-bottom: 20px;
            border-bottom: 1px solid rgba(0, 243, 255, 0.1);
        }
        .app-title { 
            font-size: 28px; font-weight: 900; letter-spacing: 4px; 
            color: #fff; margin: 0; line-height: 1.2;
            text-shadow: 0 0 10px var(--neon-cyan);
        }
        .app-slogan { 
            font-size: 10px; color: var(--neon-orange); 
            text-transform: uppercase; letter-spacing: 2px; 
            margin-top: 8px; opacity: 0.9;
            text-shadow: 0 0 5px var(--neon-orange);
        }

        /* Áä∂ÊÄÅÂç°Áâá */
        .status-card {
            background: rgba(0, 243, 255, 0.05); 
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-radius: var(--border-radius);
            padding: 15px; text-align: center;
            margin-bottom: 20px;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.05);
        }
        .status-title { font-size: 10px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 2px; margin-bottom: 4px; }
        .status-value { font-size: 16px; font-weight: 700; display: flex; align-items: center; justify-content: center; gap: 10px; letter-spacing: 1px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; box-shadow: 0 0 8px currentColor; }

        /* Âä®ÊÄÅÈù¢Êùø */
        #dynamic-panel {
            flex: 1; display: flex; flex-direction: column; justify-content: flex-start; padding-top: 10px; gap: 20px;
        }

        /* Grid */
        .tool-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; width: 100%; }
        
        .tool-btn {
            background: rgba(255,255,255,0.03); 
            border: 1px solid rgba(255,255,255,0.1);
            color: var(--text-primary); height: 90px; padding: 10px;
            border-radius: var(--border-radius); 
            font-family: 'Orbitron', sans-serif;
            font-size: 14px; font-weight: 500;
            cursor: pointer; display: flex; flex-direction: column; 
            align-items: center; justify-content: center; gap: 8px;
            transition: all 0.2s;
        }
        .tool-btn:hover { 
            background: rgba(0, 243, 255, 0.1); 
            border-color: var(--neon-cyan);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
            transform: translateY(-2px); 
        }
        .tool-btn:active { transform: scale(0.98); }
        
        .plus-icon {
            width: 24px; height: 24px; 
            border: 2px solid var(--neon-cyan); border-radius: 50%; 
            position: relative; margin-bottom: 2px;
            box-shadow: 0 0 5px var(--neon-cyan);
        }
        .plus-icon::before, .plus-icon::after {
            content: ''; position: absolute; background: var(--neon-cyan);
            left: 50%; top: 50%; transform: translate(-50%, -50%);
            box-shadow: 0 0 5px var(--neon-cyan);
        }
        .plus-icon::before { width: 12px; height: 2px; } 
        .plus-icon::after { width: 2px; height: 12px; }
        .trash-icon { font-size: 20px; margin-bottom: 4px; filter: drop-shadow(0 0 5px var(--neon-red)); }

        .btn-text-cn { font-size: 13px; font-weight: 700; color: #fff; font-family: "Microsoft YaHei", sans-serif; }
        .btn-text-en { font-size: 10px; color: var(--text-secondary); font-weight: 400; letter-spacing: 1px; }

        .btn-clear { border-color: rgba(255, 0, 60, 0.3); }
        .btn-clear:hover { background: rgba(255, 0, 60, 0.1); border-color: var(--neon-red); box-shadow: 0 0 15px rgba(255,0,60,0.2); }
        .btn-clear .btn-text-en { color: rgba(255, 0, 60, 0.7); }

        /* ÊñáÊ°à */
        .hint-block {
            margin-top: 15px; padding: 12px; 
            background: rgba(255,255,255,0.03); border-radius: 8px;
            font-size: 12px; line-height: 1.8; color: var(--text-secondary);
            font-family: "Microsoft YaHei", sans-serif;
        }
        .hint-title { 
            color: var(--neon-cyan); font-weight: 700; font-size: 13px; margin-bottom: 5px; display: block; 
            text-shadow: 0 0 5px rgba(0,243,255,0.3); font-family: 'Orbitron', sans-serif; letter-spacing: 1px;
        }
        .key-badge { 
            border: 1px solid var(--text-secondary); padding: 1px 6px; 
            border-radius: 4px; font-size: 10px; color: #fff;
        }

        /* ‰ª™Ë°®Áõò */
        #panel-dashboard { display: none; text-align: center; margin-top: 40px;}
        .gear-row { display: flex; justify-content: center; gap: 30px; margin-bottom: 20px; }
        .gear { font-size: 24px; font-weight: 700; color: #334; transition: 0.2s; }
        .gear.active { color: var(--neon-cyan); transform: scale(1.2); text-shadow: 0 0 15px var(--neon-cyan); }
        .speed-large { font-size: 80px; font-weight: 900; line-height: 1; letter-spacing: 2px; color: #fff; text-shadow: 0 0 20px rgba(255,255,255,0.5); }
        .speed-unit { font-size: 14px; color: var(--text-secondary); margin-top: 5px; letter-spacing: 2px; }

        /* Â∫ïÈÉ®ÊåâÈíÆ */
        .bottom-section { margin-top: auto; }
        .main-btn {
            width: 100%; height: 64px; border-radius: var(--border-radius);
            border: none; font-size: 18px; font-weight: 900; letter-spacing: 2px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer; transition: all 0.3s;
            text-transform: uppercase;
        }
        .btn-mode-edit { background: var(--neon-cyan); color: #000; box-shadow: 0 0 20px rgba(0, 243, 255, 0.4); }
        .btn-mode-edit:hover { background: #fff; box-shadow: 0 0 30px rgba(0, 243, 255, 0.8); }
        .btn-mode-drive { background: rgba(255, 0, 60, 0.1); border: 1px solid var(--neon-red); color: var(--neon-red); box-shadow: 0 0 15px rgba(255, 0, 60, 0.2); }
        .btn-mode-drive:hover { background: rgba(255, 0, 60, 0.2); box-shadow: 0 0 25px rgba(255, 0, 60, 0.5); }
        .footer-copyright { margin-top: 20px; text-align: center; font-size: 10px; color: #445; letter-spacing: 1px; }

        /* Âè≥‰æßÁîªÂ∏É */
        #canvas-area { 
            flex: 1; position: relative; 
            background-color: #020204; 
            background-image: 
                linear-gradient(rgba(0, 243, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 243, 255, 0.05) 1px, transparent 1px);
            background-size: 44px 44px; 
            display: flex; align-items: center; justify-content: center; z-index: 1; 
            box-shadow: inset 10px 0 50px rgba(0,0,0,0.5); 
        }
        canvas { 
            background-color: rgba(0,0,0,0.5); 
            border-radius: 4px; 
            border: 1px solid rgba(0, 243, 255, 0.3);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.15);
        }

        /* Á¢∞ÊíûÁ∫¢ÂÖâ */
        #crash-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; opacity: 0; transition: opacity 0.2s;
            background: radial-gradient(circle, transparent 40%, rgba(255, 0, 60, 0.5) 100%);
            z-index: 50; border: 2px solid var(--neon-red);
        }
        #crash-overlay.active { animation: glitch 0.2s infinite; opacity: 1; }
        @keyframes glitch {
            0% { transform: translate(0,0); border-color: var(--neon-red); }
            20% { transform: translate(-2px,2px); border-color: #fff; }
            100% { transform: translate(0,0); }
        }
    </style>
</head>
<body>

    <audio id="audio-bgm" src="BGM.mp3" loop preload="auto"></audio>
    <audio id="audio-crash" src="Crash.mp3" preload="auto"></audio>

    <div id="mobile-blocker">
        <div class="mobile-icon">üö´</div>
        <div class="mobile-title">ACCESS DENIED</div>
        <div class="mobile-desc">
            System requires desktop terminal.<br>
            ËØ∑‰ΩøÁî®ÁîµËÑëÊµèËßàÂô®ËÆøÈóÆ‰ª•Êé•ÂÖ•Á≥ªÁªü„ÄÇ
        </div>
    </div>

    <div id="app-container">
        <div id="sidebar">
            <div id="brand-header">
                <h1 class="app-title">PARKING LAB</h1>
                <div class="app-slogan">Master the Art of Parking</div>
            </div>

            <div class="status-card">
                <div class="status-title">System Status</div>
                <div class="status-value" id="status-display">
                    <div class="dot" style="background:var(--neon-orange); box-shadow:0 0 10px var(--neon-orange)"></div>
                    <span style="color:var(--neon-orange)">EDIT MODE</span>
                </div>
            </div>

            <div id="dynamic-panel">
                
                <div id="panel-tools" class="tool-grid">
                    <button class="tool-btn" onclick="addObject('spot')">
                        <div class="plus-icon"></div>
                        <div><div class="btn-text-cn">Ê∑ªÂä†ËΩ¶‰Ωç</div><div class="btn-text-en">SPOT</div></div>
                    </button>
                    <button class="tool-btn" onclick="addObject('obstacle_car')">
                        <div class="plus-icon"></div>
                        <div><div class="btn-text-cn">Ê∑ªÂä†ËΩ¶ËæÜ</div><div class="btn-text-en">VEHICLE</div></div>
                    </button>
                    <button class="tool-btn" onclick="addObject('wall')">
                        <div class="plus-icon"></div>
                        <div><div class="btn-text-cn">Ê∑ªÂä†Â¢ô‰Ωì</div><div class="btn-text-en">BARRIER</div></div>
                    </button>
                    <button class="tool-btn btn-clear" onclick="resetScene()">
                        <div class="trash-icon">üóëÔ∏è</div>
                        <div><div class="btn-text-cn">Ê∏ÖÁ©∫Âú∞Âõæ</div><div class="btn-text-en">PURGE</div></div>
                    </button>
                </div>
                
                <div id="hint-edit" class="hint-block">
                    <span class="hint-title">ÁºñËæë‰Ω†ÁöÑÂÅúËΩ¶Âú∞Âõæ</span>
                    - ÂèåÂáªÁâ©‰ΩìÊóãËΩ¨ 90¬∞<br>
                    - Èº†Ê†áÊãñÊãΩË∞ÉÊï¥Áâ©‰Ωì‰ΩçÁΩÆ
                </div>

                <div id="panel-dashboard">
                    <div class="gear-row">
                        <span id="gear-r" class="gear">R</span>
                        <span id="gear-n" class="gear">N</span>
                        <span id="gear-d" class="gear">D</span>
                    </div>
                    <div class="speed-large"><span id="speed">0</span></div>
                    <div class="speed-unit">KM/H</div>
                    
                    <div class="hint-block" style="text-align: left; margin-top:30px">
                        <span class="hint-title">È©æÈ©∂Êìç‰Ωú</span>
                        - ‰ΩøÁî®ÈîÆÁõòÊñπÂêëÈîÆÊéßÂà∂ËΩ¶ËæÜ<br>
                        - Êåâ‰∏ã <span class="key-badge">Space</span> Ëá™Âä®ÂõûÊ≠£ÊñπÂêë
                    </div>
                </div>
            </div>

            <div class="bottom-section">
                <button id="main-btn" class="main-btn btn-mode-edit" onclick="toggleMode()">INITIALIZE</button>
                <div class="footer-copyright">¬© 2025 THE PARKING LAB.</div>
            </div>
        </div>

        <div id="canvas-area">
            <div id="crash-overlay"></div>
            <canvas id="gameCanvas" width="1100" height="900"></canvas>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Refs
    const statusDisplay = document.getElementById('status-display');
    const panelTools = document.getElementById('panel-tools');
    const hintEdit = document.getElementById('hint-edit');
    const panelDashboard = document.getElementById('panel-dashboard');
    const mainBtn = document.getElementById('main-btn');
    const crashOverlay = document.getElementById('crash-overlay');
    
    // Audio Refs
    const audioBgm = document.getElementById('audio-bgm');
    const audioCrash = document.getElementById('audio-crash');
    audioBgm.volume = 0.3;
    audioCrash.volume = 0.5;

    const SCALE = 22; 
    let MODE = 'EDIT'; 
    let isColliding = false; 
    let wasColliding = false;

    // Car Colors
    const CAR_COLORS = [ 
        { hex: '#555', name: 'Carbon' }, 
        { hex: '#0033cc', name: 'Neon Blue' }, 
        { hex: '#cc0000', name: 'Neon Red' } 
    ];

    // Objects
    const car = {
        type: 'player', x: 550, y: 450, length: 4.72 * SCALE, width: 1.85 * SCALE, mirrorGap: 0.12 * SCALE, wheelBase: 2.875 * SCALE,
        angle: -Math.PI / 2, 
        speed: 0, 
        maxSpeed: 2.0,
        acceleration: 0.04, friction: 0.92,
        steeringAngle: 0, maxSteeringAngle: 0.61, 
        steeringSpeed: 0.035,
        color: '#ffffff'
    };

    let objects = [ { type: 'spot', x: 350, y: 250, width: 2.5 * SCALE, height: 5.3 * SCALE, angle: 0 } ];
    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Space: false };

    // --- Interaction ---
    function getMousePos(evt) { const rect = canvas.getBoundingClientRect(); return { x: evt.clientX - rect.left, y: evt.clientY - rect.top }; }
    function getDistance(x1, y1, x2, y2) { return Math.sqrt((x2-x1)**2 + (y2-y1)**2); }
    function isPointInObj(x, y, obj) {
        const padding = 30; let cx = obj.x; let cy = obj.y; let w, h;
        if (obj.type === 'spot') { cx = obj.x + obj.width/2; cy = obj.y + obj.height/2; w = obj.width; h = obj.height; } 
        else { if (obj.type === 'player' || obj.type === 'obstacle_car') { w = obj.length; h = obj.width; } else { w = obj.width; h = obj.height; } }
        let halfSize = Math.max(w, h) / 2 + padding; 
        return x > cx - halfSize && x < cx + halfSize && y > cy - halfSize && y < cy + halfSize;
    }

    let isDragging = false; let dragTarget = null; let dragOffset = { x: 0, y: 0 };

    canvas.addEventListener('mousedown', (e) => {
        if (MODE !== 'EDIT') return;
        const m = getMousePos(e);
        let candidates = [];
        if (isPointInObj(m.x, m.y, car)) candidates.push({ obj: car, dist: getDistance(m.x, m.y, car.x, car.y) });
        for (let obj of objects) {
            let cx = obj.x; let cy = obj.y; if (obj.type === 'spot') { cx = obj.x + obj.width/2; cy = obj.y + obj.height/2; }
            if (isPointInObj(m.x, m.y, obj)) candidates.push({ obj: obj, dist: getDistance(m.x, m.y, cx, cy) });
        }
        if (candidates.length > 0) {
            candidates.sort((a, b) => a.dist - b.dist);
            isDragging = true; dragTarget = candidates[0].obj;
            dragOffset = { x: m.x - dragTarget.x, y: m.y - dragTarget.y };
        }
    });
    canvas.addEventListener('mousemove', (e) => { if (isDragging && MODE === 'EDIT' && dragTarget) { const m = getMousePos(e); dragTarget.x = m.x - dragOffset.x; dragTarget.y = m.y - dragOffset.y; } });
    canvas.addEventListener('mouseup', () => { isDragging = false; dragTarget = null; });
    canvas.addEventListener('dblclick', (e) => {
        if (MODE !== 'EDIT') return;
        const m = getMousePos(e);
        let candidates = [];
        if (isPointInObj(m.x, m.y, car)) candidates.push({obj:car, dist: getDistance(m.x,m.y,car.x,car.y)});
        for (let obj of objects) {
            let cx = obj.x; let cy = obj.y; if(obj.type==='spot'){cx+=obj.width/2; cy+=obj.height/2;}
            if (isPointInObj(m.x, m.y, obj)) candidates.push({obj:obj, dist: getDistance(m.x,m.y,cx,cy)});
        }
        if (candidates.length > 0) {
            candidates.sort((a, b) => a.dist - b.dist);
            let obj = candidates[0].obj;
            if (obj.type === 'spot') { let temp = obj.width; obj.width = obj.height; obj.height = temp; } else { obj.angle += Math.PI / 2; }
        }
    });
    document.addEventListener('keydown', (e) => { if(e.code === 'Space') { e.preventDefault(); keys.Space = true; } if(keys.hasOwnProperty(e.code)) keys[e.code] = true; });
    document.addEventListener('keyup', (e) => { if(e.code === 'Space') keys.Space = false; if(keys.hasOwnProperty(e.code)) keys[e.code] = false; });

    // --- Mode Logic ---
    function toggleMode() {
        mainBtn.blur();
        if (MODE === 'EDIT') {
            MODE = 'DRIVE';
            statusDisplay.innerHTML = `<div class="dot" style="background:var(--neon-cyan); box-shadow:0 0 10px var(--neon-cyan)"></div><span style="color:var(--neon-cyan)">DRIVING</span>`;
            panelTools.style.display = 'none';
            hintEdit.style.display = 'none';
            panelDashboard.style.display = 'block';
            mainBtn.innerText = "ABORT / EDIT";
            mainBtn.className = "main-btn btn-mode-drive";
            canvas.style.cursor = 'crosshair';
            audioBgm.play().catch(e => console.log('Audio play failed', e));
        } else {
            MODE = 'EDIT';
            statusDisplay.innerHTML = `<div class="dot" style="background:var(--neon-orange); box-shadow:0 0 10px var(--neon-orange)"></div><span style="color:var(--neon-orange)">EDIT MODE</span>`;
            panelTools.style.display = 'grid'; 
            hintEdit.style.display = 'block';
            panelDashboard.style.display = 'none';
            mainBtn.innerText = "INITIALIZE";
            mainBtn.className = "main-btn btn-mode-edit";
            canvas.style.cursor = 'default';
            car.speed = 0; car.steeringAngle = 0; isColliding = false; 
            crashOverlay.classList.remove('active');
            audioBgm.pause(); audioBgm.currentTime = 0;
        }
    }

    function addObject(type) {
        mainBtn.blur();
        let offX = (Math.random() - 0.5) * 60; let offY = (Math.random() - 0.5) * 60;
        if(type === 'wall') objects.push({ type: 'wall', x: 550+offX, y: 450+offY, width: 10 * SCALE, height: 0.6 * SCALE, angle: 0 });
        else if (type === 'obstacle_car') {
            let color = CAR_COLORS[Math.floor(Math.random() * CAR_COLORS.length)].hex;
            objects.push({ type: 'obstacle_car', x: 550+offX, y: 450+offY, length: 4.72 * SCALE, width: 1.85 * SCALE, angle: -Math.PI/2, color: color });
        } else if (type === 'spot') objects.push({ type: 'spot', x: 550+offX, y: 450+offY, width: 2.5 * SCALE, height: 5.3 * SCALE, angle: 0 });
    }
    function resetScene() { mainBtn.blur(); objects = []; addObject('spot'); }

    // --- Physics ---
    function getRectCorners(obj) {
        let cx = obj.x; let cy = obj.y; let ang = obj.angle || 0;
        if (obj.type === 'spot') { cx = obj.x + obj.width/2; cy = obj.y + obj.height/2; }
        let hw, hh;
        if (obj.type === 'player' || obj.type === 'obstacle_car') { hw = obj.length/2; hh = obj.width/2; } else { hw = obj.width/2; hh = obj.height/2; }
        let cos = Math.cos(ang); let sin = Math.sin(ang);
        return [ { x: cx + hw*cos - hh*sin, y: cy + hw*sin + hh*cos }, { x: cx - hw*cos - hh*sin, y: cy - hw*sin + hh*cos }, { x: cx - hw*cos + hh*sin, y: cy - hw*sin - hh*cos }, { x: cx + hw*cos + hh*sin, y: cy + hw*sin - hh*cos } ];
    }
    function checkCollision(objA, objB) {
        if (objB.type === 'spot') return false; 
        const cornersA = getRectCorners(objA); const cornersB = getRectCorners(objB);
        const polygons = [cornersA, cornersB];
        for (let polygon of polygons) {
            for (let i = 0; i < polygon.length; i++) {
                const p1 = polygon[i]; const p2 = polygon[(i + 1) % polygon.length];
                const normal = { x: p2.y - p1.y, y: p1.x - p2.x };
                let minA = Infinity, maxA = -Infinity;
                for (let p of cornersA) { const proj = normal.x * p.x + normal.y * p.y; if (proj < minA) minA = proj; if (proj > maxA) maxA = proj; }
                let minB = Infinity, maxB = -Infinity;
                for (let p of cornersB) { const proj = normal.x * p.x + normal.y * p.y; if (proj < minB) minB = proj; if (proj > maxB) maxB = proj; }
                if (maxA < minB || maxB < minA) return false;
            }
        }
        return true;
    }
    function updatePhysics() {
        if (MODE !== 'DRIVE') return;
        if (keys.Space) { car.steeringAngle *= 0.85; if (Math.abs(car.steeringAngle) < 0.005) car.steeringAngle = 0; } 
        else { if (keys.ArrowLeft) car.steeringAngle -= car.steeringSpeed; if (keys.ArrowRight) car.steeringAngle += car.steeringSpeed; }
        if (car.steeringAngle > car.maxSteeringAngle) car.steeringAngle = car.maxSteeringAngle;
        if (car.steeringAngle < -car.maxSteeringAngle) car.steeringAngle = -car.maxSteeringAngle;
        if (keys.ArrowUp) car.speed += car.acceleration; else if (keys.ArrowDown) car.speed -= car.acceleration; else car.speed *= car.friction;
        if (car.speed > car.maxSpeed) car.speed = car.maxSpeed; if (car.speed < -car.maxSpeed) car.speed = -car.maxSpeed; if (Math.abs(car.speed) < 0.02) car.speed = 0;
        
        if (Math.abs(car.speed) > 0) {
            let nextX = car.x + Math.cos(car.angle) * car.speed;
            let nextY = car.y + Math.sin(car.angle) * car.speed;
            let hitBorder = false;
            if (nextX < 20 || nextX > canvas.width - 20 || nextY < 20 || nextY > canvas.height - 20) { hitBorder = true; car.speed = 0; } 
            else { car.x = nextX; car.y = nextY; }
            car.angle += (car.speed * Math.tan(car.steeringAngle)) / car.wheelBase;
            let currentFrameCollision = false;
            for (let obj of objects) { if (checkCollision(car, obj)) { currentFrameCollision = true; break; } }
            if (hitBorder) currentFrameCollision = true;
            if (currentFrameCollision && !wasColliding) { audioCrash.currentTime = 0; audioCrash.play().catch(e => console.log('Crash play failed', e)); }
            wasColliding = currentFrameCollision; 
            isColliding = currentFrameCollision;
            if(isColliding) crashOverlay.classList.add('active'); else crashOverlay.classList.remove('active');
        }
    }

    // --- RENDERER ---
    function drawStreamlinedBody(ctx, length, width, color) {
        ctx.fillStyle = color; const hw = length / 2; const hh = width / 2;
        ctx.beginPath(); ctx.moveTo(-hw, -hh + 5); ctx.lineTo(-hw, hh - 5); ctx.quadraticCurveTo(-hw, hh, -hw + 10, hh); ctx.lineTo(hw - 15, hh); ctx.quadraticCurveTo(hw, hh, hw, 0); ctx.quadraticCurveTo(hw, -hh, hw - 15, -hh); ctx.lineTo(-hw + 10, -hh); ctx.quadraticCurveTo(-hw, -hh, -hw, -hh + 5); ctx.fill();
        let grad = ctx.createLinearGradient(-hw, -hh, -hw, hh); grad.addColorStop(0, "rgba(255,255,255,0.4)"); grad.addColorStop(0.2, "rgba(255,255,255,0.1)"); grad.addColorStop(0.5, "rgba(0,0,0,0.1)"); grad.addColorStop(0.8, "rgba(0,0,0,0.3)"); ctx.fillStyle = grad; ctx.fill();
    }
    function drawGlassRoof(ctx, length, width) {
        ctx.fillStyle = "#000"; const hw = length / 2; const hh = width / 2; const insetY = 4;
        ctx.beginPath(); ctx.moveTo(hw - 25, -hh + insetY); ctx.lineTo(hw - 25, hh - insetY); ctx.lineTo(hw - 5, hh - 6); ctx.quadraticCurveTo(hw - 2, 0, hw - 5, -hh + 6); ctx.fill();
        ctx.beginPath(); ctx.roundRect(-hw + 15, -hh + 6, length - 55, width - 12, 4); ctx.fill();
    }
    function drawCar(obj, isPlayer) {
        ctx.save(); ctx.translate(obj.x, obj.y); ctx.rotate(obj.angle);
        if (isPlayer && MODE === 'DRIVE') { ctx.shadowColor = "#00F3FF"; ctx.shadowBlur = 40; } else { ctx.shadowColor = "rgba(0,0,0,0.8)"; ctx.shadowBlur = 10; }
        drawStreamlinedBody(ctx, obj.length, obj.width, obj.color); ctx.shadowBlur = 0; 
        drawGlassRoof(ctx, obj.length, obj.width);
        ctx.fillStyle = obj.color; ctx.fillRect(obj.length/3.5, obj.width/2 - 2, 10, car.mirrorGap + 2); ctx.fillRect(obj.length/3.5, -obj.width/2 - car.mirrorGap, 10, car.mirrorGap + 2);
        ctx.shadowColor = "#FFF"; ctx.shadowBlur = 10; ctx.fillStyle = "#FFF"; ctx.beginPath(); ctx.ellipse(obj.length/2 - 6, -obj.width/2 + 4, 6, 2, Math.PI/4, 0, 2*Math.PI); ctx.fill(); ctx.beginPath(); ctx.ellipse(obj.length/2 - 6, obj.width/2 - 4, 6, 2, -Math.PI/4, 0, 2*Math.PI); ctx.fill(); ctx.shadowBlur = 0;
        let tailColor = (isPlayer && keys.ArrowDown) ? "#FF003C" : "#500"; ctx.fillStyle = tailColor; ctx.fillRect(-obj.length/2, -obj.width/2 + 2, 3, 12); ctx.fillRect(-obj.length/2, obj.width/2 - 14, 3, 12);
        if (MODE === 'EDIT' && isDragging && dragTarget === obj) { ctx.strokeStyle = "#00F3FF"; ctx.lineWidth = 2; ctx.strokeRect(-obj.length/2 - 5, -obj.width/2 - 5, obj.length + 10, obj.width + 10); }
        ctx.restore();
    }
    function drawSpot(obj) {
        ctx.save(); ctx.translate(obj.x, obj.y);
        ctx.shadowColor = "#00F3FF"; ctx.shadowBlur = 10; ctx.strokeStyle = "rgba(0, 243, 255, 0.8)"; ctx.lineWidth = 2; ctx.fillStyle = "rgba(0, 243, 255, 0.05)"; ctx.beginPath(); ctx.rect(0, 0, obj.width, obj.height); ctx.fill(); ctx.stroke();
        ctx.fillStyle = "rgba(0, 243, 255, 0.8)"; ctx.font = "bold 28px 'Orbitron'"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText("P", obj.width/2, obj.height/2); ctx.shadowBlur = 0;
        if (MODE === 'EDIT' && isDragging && dragTarget === obj) { ctx.strokeStyle = "#FFF"; ctx.strokeRect(-2,-2,obj.width+4,obj.height+4); }
        ctx.restore();
    }
    function drawWall(obj) {
        ctx.save(); ctx.translate(obj.x, obj.y); ctx.rotate(obj.angle); const w = obj.width; const h = obj.height;
        ctx.shadowColor = "#AAA"; ctx.shadowBlur = 10; ctx.strokeStyle = "#AAA"; ctx.lineWidth = 1; ctx.fillStyle = "rgba(180, 180, 190, 0.3)"; 
        ctx.fillRect(-w/2, -h/2, w, h); ctx.strokeRect(-w/2, -h/2, w, h); ctx.beginPath(); ctx.moveTo(-w/2, 0); ctx.lineTo(w/2, 0); ctx.stroke(); ctx.shadowBlur = 0;
        if (MODE === 'EDIT' && isDragging && dragTarget === obj) { ctx.strokeStyle = "#FFF"; ctx.strokeRect(-w/2-4, -h/2-4, w+8, h+8); }
        ctx.restore();
    }
    
    // ‰ºòÂåñÁöÑÂÖâÊµÅÂºïÂØºÁ∫ø (Reverted Logic, New Visuals)
    function drawPrediction(direction) {
        if (MODE === 'EDIT') return; 
        
        ctx.save(); 
        
        // Gap Fix: Start from car's origin relative to world
        let simX = car.x; let simY = car.y; let simAngle = car.angle; 
        let safeWidth = car.width + (car.mirrorGap * 2);
        
        // Length restored to 90
        const STEPS = 90; 
        let leftPath = []; let rightPath = []; 

        const ribbonColor = "255, 255, 255"; 

        for (let i = 0; i < STEPS; i++) {
            let simSpeed = 2.0 * direction; 
            simX += Math.cos(simAngle) * simSpeed; 
            simY += Math.sin(simAngle) * simSpeed; 
            simAngle += (simSpeed * Math.tan(car.steeringAngle)) / car.wheelBase;
            
            let offsetX = Math.cos(simAngle - Math.PI/2) * (safeWidth/2); 
            let offsetY = Math.sin(simAngle - Math.PI/2) * (safeWidth/2);
            
            leftPath.push({x: simX + offsetX, y: simY + offsetY}); 
            rightPath.push({x: simX - offsetX, y: simY - offsetY});
        }

        // Gradient Glow
        let lastP = leftPath[leftPath.length-1];
        let grad = ctx.createLinearGradient(car.x, car.y, lastP.x, lastP.y);
        grad.addColorStop(0, `rgba(${ribbonColor}, 0.3)`);
        grad.addColorStop(1, `rgba(${ribbonColor}, 0)`);

        ctx.beginPath();
        ctx.moveTo(leftPath[0].x, leftPath[0].y);
        for(let p of leftPath) ctx.lineTo(p.x, p.y);
        for(let i = rightPath.length - 1; i >= 0; i--) ctx.lineTo(rightPath[i].x, rightPath[i].y);
        ctx.closePath();
        ctx.fillStyle = grad;
        ctx.shadowColor = `rgba(${ribbonColor}, 0.8)`; ctx.shadowBlur = 10;
        ctx.fill();
        
        // Edge lines
        ctx.strokeStyle = grad; ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(leftPath[0].x, leftPath[0].y); for(let p of leftPath) ctx.lineTo(p.x, p.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(rightPath[0].x, rightPath[0].y); for(let p of rightPath) ctx.lineTo(p.x, p.y);
        ctx.stroke();

        ctx.restore();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (MODE === 'EDIT') {
            ctx.save(); ctx.strokeStyle = "rgba(0, 243, 255, 0.1)"; ctx.lineWidth = 1; ctx.beginPath(); 
            for (let i = 0; i < canvas.width; i += SCALE * 2) { ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); } for (let i = 0; i < canvas.height; i += SCALE * 2) { ctx.moveTo(0, i); ctx.lineTo(canvas.width, i); } 
            ctx.stroke(); ctx.restore();
        }
        for (let obj of objects) { if (obj.type === 'spot') drawSpot(obj); } 
        for (let obj of objects) { if (obj.type === 'wall') drawWall(obj); } 
        for (let obj of objects) { if (obj.type === 'obstacle_car') drawCar(obj, false); }
        
        // Logic Reverted: Show based on speed
        if (Math.abs(car.speed) < 1.0) {
            drawPrediction(1); drawPrediction(-1);
        } else {
            drawPrediction(car.speed > 0 ? 1 : -1);
        }
        
        drawCar(car, true); 
        
        document.getElementById('speed').innerText = Math.abs(Math.round(car.speed * 10));
        const r = document.getElementById('gear-r'); const n = document.getElementById('gear-n'); const d = document.getElementById('gear-d');
        r.className = "gear"; n.className = "gear"; d.className = "gear";
        if (car.speed < -0.1) r.className += " active"; else if (car.speed > 0.1) d.className += " active"; else n.className += " active";
    }
    function loop() { if (MODE === 'DRIVE') { updatePhysics(); } draw(); requestAnimationFrame(loop); }
    loop();
</script>
</body>
</html>
